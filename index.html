<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hand Gesture Drawing with MediaPipe</title>
    <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
    <style>
        body {
            font-family: roboto;
            margin: 2em;
            color: #3d3d3d;
            --mdc-theme-primary: #007f8b;
            --mdc-theme-on-primary: #f1f3f4;
        }

        h1 {
            color: #007f8b;
        }

        h2 {
            clear: both;
        }

        video {
            clear: both;
            display: block;
            transform: rotateY(180deg);
            -webkit-transform: rotateY(180deg);
            -moz-transform: rotateY(180deg);
            height: 280px;
        }

        section {
            opacity: 1;
            transition: opacity 500ms ease-in-out;
        }

        .removed {
            display: none;
        }

        .invisible {
            opacity: 0.2;
        }

        .detectOnClick {
            position: relative;
            float: left;
            width: 48%;
            margin: 2% 1%;
            cursor: pointer;
        }

        .videoView {
            position: relative;
            float: left;
            width: 48%;
            margin: 2% 1%;
            min-height: 500px;
        }

        .videoView p,
        .detectOnClick p {
            padding-top: 5px;
            padding-bottom: 5px;
            background-color: #007f8b;
            color: #fff;
            border: 1px dashed rgba(255, 255, 255, 0.7);
            z-index: 2;
            margin: 0;
        }

        #drawingCanvas {
            border: 1px solid #000;
            clear: both;
            display: block;
        }

        .detectOnClick img {
            width: 45vw;
        }

        .output {
            width: 100%;
            font-size: calc(8px + 1.2vw);
        }

        #toolbar {
            margin: 10px 0;
            padding: 10px;
            background: #f0f0f0;
            border: 1px solid #ccc;
            clear: both;
        }

        .color-btn {
            width: 30px;
            height: 30px;
            margin: 0 5px;
            border: 1px solid #000;
            cursor: pointer;
            display: inline-block;
        }

        .tool-btn {
            padding: 5px 10px;
            margin: 0 5px;
            cursor: pointer;
        }

        .selected {
            border: 2px solid #007f8b;
        }
    </style>
</head>
<body>
    <h1>Draw with Hand Gestures using MediaPipe</h1>

    <section id="demos" class="invisible">
        <h2>Demo: Hand Gesture Drawing</h2>
        <p>Use your index finger to move the cursor on the canvas below. Bring index and middle fingers together to draw.</p>

        <div id="toolbar">
            <button id="brushTool" class="tool-btn selected">Brush</button>
            <button id="eraserTool" class="tool-btn">Eraser</button>
            <div>
                Colors:
                <div class="color-btn" style="background: #000000" data-color="#000000"></div>
                <div class="color-btn" style="background: #FF0000" data-color="#FF0000"></div>
                <div class="color-btn" style="background: #00FF00" data-color="#00FF00"></div>
                <div class="color-btn" style="background: #0000FF" data-color="#0000FF"></div>
                <div class="color-btn" style="background: #FFFF00" data-color="#FFFF00"></div>
            </div>
        </div>

        <div id="liveView" class="videoView">
            <button id="webcamButton" class="mdc-button mdc-button--raised">
                <span class="mdc-button__ripple"></span>
                <span class="mdc-button__label">ENABLE WEBCAM</span>
            </button>
            <div style="position: relative;">
                <video id="webcam" autoplay playsinline></video>
                <p id='gesture_output' class="output"></p>
            </div>
        </div>

        <!-- Separate drawing canvas -->
        <canvas id="drawingCanvas" width="1280" height="720"></canvas>
    </section>

    <script type="module">
        import {
            GestureRecognizer,
            FilesetResolver
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const demosSection = document.getElementById("demos");
        let gestureRecognizer;
        let runningMode = "IMAGE";
        let enableWebcamButton;
        let webcamRunning = false;
        const videoHeight = "280px";
        const videoWidth = "480px";

        // Drawing variables
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentColor = "#000000";
        let currentTool = "brush";
        let cursorX = 0;
        let cursorY = 0;

        const createGestureRecognizer = async () => {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath:
                        "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                    delegate: "GPU"
                },
                runningMode: runningMode,
                numHands: 2
            });
            demosSection.classList.remove("invisible");
        };
        createGestureRecognizer();

        const video = document.getElementById("webcam");
        const canvasElement = document.getElementById("drawingCanvas");
        const canvasCtx = canvasElement.getContext("2d");
        const gestureOutput = document.getElementById("gesture_output");

        function hasGetUserMedia() {
            return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        }

        if (hasGetUserMedia()) {
            enableWebcamButton = document.getElementById("webcamButton");
            enableWebcamButton.addEventListener("click", enableCam);
        } else {
            console.warn("getUserMedia() is not supported by your browser");
        }

        function enableCam(event) {
            if (!gestureRecognizer) {
                alert("Please wait for gestureRecognizer to load");
                return;
            }

            if (webcamRunning === true) {
                webcamRunning = false;
                enableWebcamButton.innerText = "ENABLE WEBCAM";
            } else {
                webcamRunning = true;
                enableWebcamButton.innerText = "DISABLE WEBCAM";
            }

            const constraints = { video: true };
            navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
            });
        }

        // Toolbar functionality
        document.getElementById("brushTool").addEventListener("click", () => {
            currentTool = "brush";
            updateToolSelection();
        });

        document.getElementById("eraserTool").addEventListener("click", () => {
            currentTool = "eraser";
            updateToolSelection();
        });

        document.querySelectorAll(".color-btn").forEach(btn => {
            btn.addEventListener("click", () => {
                currentColor = btn.dataset.color;
                updateColorSelection();
            });
        });

        function updateToolSelection() {
            document.querySelectorAll(".tool-btn").forEach(btn => {
                btn.classList.remove("selected");
                if (btn.id === `${currentTool}Tool`) btn.classList.add("selected");
            });
        }

        function updateColorSelection() {
            document.querySelectorAll(".color-btn").forEach(btn => {
                btn.style.border = btn.dataset.color === currentColor ? "2px solid #007f8b" : "1px solid #000";
            });
        }

        let lastVideoTime = -1;
        let results = undefined;

        async function predictWebcam() {
            const webcamElement = document.getElementById("webcam");
            
            if (runningMode === "IMAGE") {
                runningMode = "VIDEO";
                await gestureRecognizer.setOptions({ runningMode: "VIDEO" });
            }
            
            let nowInMs = Date.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                results = gestureRecognizer.recognizeForVideo(video, nowInMs);
            }

            // Clear the canvas for fresh cursor drawing
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            if (results.landmarks && results.landmarks.length > 0) {
                const landmarks = results.landmarks[0];
                const indexFingerTip = landmarks[8]; // Index finger tip
                const middleFingerTip = landmarks[12]; // Middle finger tip

                // Map video coordinates to canvas coordinates, adjusting for flip
                cursorX = (1 - indexFingerTip.x) * canvasElement.width; // Flip x due to rotateY(180deg)
                cursorY = indexFingerTip.y * canvasElement.height;

                // Detect click (index + middle finger close together)
                const distance = Math.sqrt(
                    Math.pow(indexFingerTip.x - middleFingerTip.x, 2) +
                    Math.pow(indexFingerTip.y - middleFingerTip.y, 2)
                );
                const isClicking = distance < 0.1;

                // Drawing logic on the canvas
                if (isClicking) {
                    if (!isDrawing) {
                        isDrawing = true;
                        lastX = cursorX;
                        lastY = cursorY;
                    }

                    canvasCtx.beginPath();
                    canvasCtx.moveTo(lastX, lastY);
                    canvasCtx.lineTo(cursorX, cursorY);
                    canvasCtx.strokeStyle = currentTool === "brush" ? currentColor : "#FFFFFF";
                    canvasCtx.lineWidth = 5;
                    canvasCtx.stroke();

                    lastX = cursorX;
                    lastY = cursorY;
                } else {
                    isDrawing = false;
                }

                // Draw cursor on the canvas
                canvasCtx.beginPath();
                canvasCtx.arc(cursorX, cursorY, 5, 0, 2 * Math.PI);
                canvasCtx.fillStyle = "rgba(0, 127, 139, 0.5)";
                canvasCtx.fill();

                // Update gesture output
                if (results.gestures.length > 0) {
                    gestureOutput.style.display = "block";
                    gestureOutput.style.width = videoWidth;
                    const gesture = results.gestures[0][0].categoryName;
                    const score = parseFloat(results.gestures[0][0].score * 100).toFixed(2);
                    const handedness = results.handednesses[0][0].displayName;
                    gestureOutput.innerText = `Gesture: ${gesture}\n Confidence: ${score} %\n Handedness: ${handedness}`;
                } else {
                    gestureOutput.style.display = "none";
                }
            }

            if (webcamRunning === true) {
                window.requestAnimationFrame(predictWebcam);
            }
        }
    </script>
</body>
</html>
