<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hand Gesture Drawing with MediaPipe</title>
    <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
    <style>
        body {
            font-family: roboto;
            margin: 2em;
            color: #3d3d3d;
            --mdc-theme-primary: #007f8b;
            --mdc-theme-on-primary: #f1f3f4;
        }

        h1 {
            color: #007f8b;
        }

        h2 {
            clear: both;
        }

        video {
            clear: both;
            display: block;
            transform: rotateY(180deg);
            -webkit-transform: rotateY(180deg);
            -moz-transform: rotateY(180deg);
            height: 280px;
        }

        section {
            opacity: 1;
            transition: opacity 500ms ease-in-out;
        }

        .removed {
            display: none;
        }

        .invisible {
            opacity: 0.2;
        }

        .detectOnClick {
            position: relative;
            float: left;
            width: 48%;
            margin: 2% 1%;
            cursor: pointer;
        }

        .videoView {
            position: relative;
            float: left;
            width: 48%;
            margin: 2% 1%;
            min-height: 500px;
        }

        .videoView p,
        .detectOnClick p {
            padding-top: 5px;
            padding-bottom: 5px;
            background-color: #007f8b;
            color: #fff;
            border: 1px dashed rgba(255, 255, 255, 0.7);
            z-index: 2;
            margin: 0;
        }

        .output_canvas {
            transform: rotateY(180deg);
            -webkit-transform: rotateY(180deg);
            -moz-transform: rotateY(180deg);
        }

        .detectOnClick img {
            width: 45vw;
        }

        .output {
            width: 100%;
            font-size: calc(8px + 1.2vw);
        }
    </style>
</head>
<body>
    <h1>Draw with Hand Gestures using MediaPipe</h1>

    <section id="demos" class="invisible">
        <h2>Demo: Hand Gesture Drawing</h2>
        <p>Use your index finger to draw on the canvas. Make a "Pointing" gesture to start drawing.</p>

        <div id="liveView" class="videoView">
            <button id="webcamButton" class="mdc-button mdc-button--raised">
                <span class="mdc-button__ripple"></span>
                <span class="mdc-button__label">ENABLE WEBCAM</span>
            </button>
            <div style="position: relative;">
                <video id="webcam" autoplay playsinline></video>
                <canvas class="output_canvas" id="output_canvas" width="1280" height="720" style="position: absolute; left: 0px; top: 0px;"></canvas>
                <p id='gesture_output' class="output"></p>
            </div>
        </div> 
    </section>

    <script type="module">
        import {
            GestureRecognizer,
            FilesetResolver,
            DrawingUtils
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const demosSection = document.getElementById("demos");
        let gestureRecognizer;
        let runningMode = "IMAGE";
        let enableWebcamButton;
        let webcamRunning = false;
        const videoHeight = "360px";
        const videoWidth = "480px";

        // Finger color mapping
        const FINGER_COLORS = {
            thumb: '#0000FF',    // Blue
            index: '#FF69B4',    // Pink
            middle: '#FF0000',   // Red
            ring: '#00FF00',     // Green
            pinky: '#FFFFFF'     // White
        };

        // Drawing variables
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        const createGestureRecognizer = async () => {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath:
                        "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                    delegate: "GPU"
                },
                runningMode: runningMode,
                numHands: 2 // Allow detection of up to 2 hands
            });
            demosSection.classList.remove("invisible");
        };
        createGestureRecognizer();

        const video = document.getElementById("webcam");
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");
        const gestureOutput = document.getElementById("gesture_output");

        function hasGetUserMedia() {
            return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        }

        if (hasGetUserMedia()) {
            enableWebcamButton = document.getElementById("webcamButton");
            enableWebcamButton.addEventListener("click", enableCam);
        } else {
            console.warn("getUserMedia() is not supported by your browser");
        }

        function enableCam(event) {
            if (!gestureRecognizer) {
                alert("Please wait for gestureRecognizer to load");
                return;
            }

            if (webcamRunning === true) {
                webcamRunning = false;
                enableWebcamButton.innerText = "ENABLE WEBCAM";
            } else {
                webcamRunning = true;
                enableWebcamButton.innerText = "DISABLE WEBCAM";
            }

            const constraints = {
                video: true
            };

            navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
            });
        }

        let lastVideoTime = -1;
        let results = undefined;
        let persistentCanvas = document.createElement("canvas");
        persistentCanvas.width = 1280;
        persistentCanvas.height = 720;
        let persistentCtx = persistentCanvas.getContext("2d");

        async function predictWebcam() {
            const webcamElement = document.getElementById("webcam");
            
            if (runningMode === "IMAGE") {
                runningMode = "VIDEO";
                await gestureRecognizer.setOptions({ runningMode: "VIDEO" });
            }
            
            let nowInMs = Date.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                results = gestureRecognizer.recognizeForVideo(video, nowInMs);
            }

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            const drawingUtils = new DrawingUtils(canvasCtx);

            canvasElement.style.height = videoHeight;
            webcamElement.style.height = videoHeight;
            canvasElement.style.width = videoWidth;
            webcamElement.style.width = videoWidth;

            // Draw persistent drawings first
            canvasCtx.drawImage(persistentCanvas, 0, 0);

            if (results.landmarks) {
                for (const landmarks of results.landmarks) {
                    const fingerConnections = [
                        {indices: [0,1,2,3,4], color: FINGER_COLORS.thumb},
                        {indices: [0,5,6,7,8], color: FINGER_COLORS.index},
                        {indices: [0,9,10,11,12], color: FINGER_COLORS.middle},
                        {indices: [0,13,14,15,16], color: FINGER_COLORS.ring},
                        {indices: [0,17,18,19,20], color: FINGER_COLORS.pinky}
                    ];

                    fingerConnections.forEach(finger => {
                        for (let i = 0; i < finger.indices.length - 1; i++) {
                            const from = landmarks[finger.indices[i]];
                            const to = landmarks[finger.indices[i + 1]];
                            canvasCtx.beginPath();
                            canvasCtx.strokeStyle = finger.color;
                            canvasCtx.lineWidth = 5;
                            canvasCtx.moveTo(from.x * canvasElement.width, from.y * canvasElement.height);
                            canvasCtx.lineTo(to.x * canvasElement.width, to.y * canvasElement.height);
                            canvasCtx.stroke();
                        }
                    });

                    drawingUtils.drawLandmarks(landmarks, {
                        color: "#FFFFFF",
                        lineWidth: 2
                    });
                }

                // Hand drawing logic
                if (results.gestures.length > 0) {
                    const gesture = results.gestures[0][0].categoryName;
                    const indexFingerTip = results.landmarks[0][8]; // Index finger tip landmark
                    
                    const currentX = indexFingerTip.x * canvasElement.width;
                    const currentY = indexFingerTip.y * canvasElement.height;

                    // Start drawing when pointing gesture is detected
                    if (gesture === "Pointing_Up" || gesture === "Pointing") {
                        if (!isDrawing) {
                            isDrawing = true;
                            lastX = currentX;
                            lastY = currentY;
                        }

                        // Draw on persistent canvas
                        persistentCtx.beginPath();
                        persistentCtx.moveTo(lastX, lastY);
                        persistentCtx.lineTo(currentX, currentY);
                        persistentCtx.strokeStyle = FINGER_COLORS.index; // Pink color for drawing
                        persistentCtx.lineWidth = 5;
                        persistentCtx.stroke();

                        lastX = currentX;
                        lastY = currentY;

                        // Update main canvas with persistent drawing
                        canvasCtx.drawImage(persistentCanvas, 0, 0);
                    } else {
                        isDrawing = false;
                    }

                    // Update gesture output
                    gestureOutput.style.display = "block";
                    gestureOutput.style.width = videoWidth;
                    const score = parseFloat(results.gestures[0][0].score * 100).toFixed(2);
                    const handedness = results.handednesses[0][0].displayName;
                    gestureOutput.innerText = `Gesture: ${gesture}\n Confidence: ${score} %\n Handedness: ${handedness}`;
                } else {
                    isDrawing = false;
                    gestureOutput.style.display = "none";
                }
            }

            canvasCtx.restore();

            if (webcamRunning === true) {
                window.requestAnimationFrame(predictWebcam);
            }
        }
    </script>
</body>
</html>
