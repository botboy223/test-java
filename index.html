<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hand Gesture Paint</title>
    <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }

        h1 {
            color: #007f8b;
        }

        #container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        #toolbar {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #ddd;
            border-radius: 5px;
        }

        #colorPicker, #brushSize, #toolToggle {
            margin: 0 10px;
        }

        #videoPreview {
            position: relative;
            width: 240px;
            height: 180px;
            border: 2px solid #007f8b;
            margin-bottom: 10px;
        }

        #webcam {
            transform: rotateY(180deg);
            -webkit-transform: rotateY(180deg);
            -moz-transform: rotateY(180deg);
            width: 100%;
            height: 100%;
        }

        #gestureOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #paintCanvas {
            border: 2px solid #007f8b;
            background-color: white;
            cursor: none; /* Hide default cursor */
        }

        #gestureOutput {
            margin-top: 10px;
            font-size: 14px;
            color: #333;
        }

        #cursor {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: red;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <h1>Hand Gesture Paint</h1>
    <div id="container">
        <div id="toolbar">
            <input type="color" id="colorPicker" value="#000000">
            <select id="brushSize">
                <option value="2">Small</option>
                <option value="5" selected>Medium</option>
                <option value="10">Large</option>
            </select>
            <button id="toolToggle">Brush</button>
            <button id="clearCanvas">Clear</button>
        </div>
        <div id="videoPreview">
            <video id="webcam" autoplay playsinline></video>
            <canvas id="gestureOverlay" width="240" height="180"></canvas>
        </div>
        <canvas id="paintCanvas" width="800" height="600"></canvas>
        <div id="cursor"></div>
        <p id="gestureOutput"></p>
    </div>

    <script type="module">
        import {
            GestureRecognizer,
            FilesetResolver,
            DrawingUtils
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        let gestureRecognizer;
        let runningMode = "IMAGE";
        let webcamRunning = false;

        const video = document.getElementById("webcam");
        const gestureOverlay = document.getElementById("gestureOverlay");
        const overlayCtx = gestureOverlay.getContext("2d");
        const paintCanvas = document.getElementById("paintCanvas");
        const paintCtx = paintCanvas.getContext("2d");
        const gestureOutput = document.getElementById("gestureOutput");
        const cursor = document.getElementById("cursor");

        const colorPicker = document.getElementById("colorPicker");
        const brushSize = document.getElementById("brushSize");
        const toolToggle = document.getElementById("toolToggle");
        const clearCanvas = document.getElementById("clearCanvas");

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let isEraser = false;

        async function createGestureRecognizer() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath:
                            "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                        delegate: "GPU"
                    },
                    runningMode: runningMode,
                    numHands: 1
                });
                console.log("Gesture Recognizer loaded");
                startWebcam();
            } catch (error) {
                console.error("Failed to load Gesture Recognizer:", error);
                alert("Error loading gesture recognition. Check console.");
            }
        }
        createGestureRecognizer();

        function startWebcam() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert("Webcam not supported");
                return;
            }

            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    video.srcObject = stream;
                    video.addEventListener("loadeddata", predictWebcam);
                    webcamRunning = true;
                })
                .catch(error => {
                    console.error("Webcam error:", error);
                    alert("Failed to start webcam");
                });
        }

        toolToggle.addEventListener("click", () => {
            isEraser = !isEraser;
            toolToggle.textContent = isEraser ? "Eraser" : "Brush";
        });

        clearCanvas.addEventListener("click", () => {
            paintCtx.clearRect(0, 0, paintCanvas.width, paintCanvas.height);
        });

        let lastVideoTime = -1;
        async function predictWebcam() {
            if (!webcamRunning) return;

            if (runningMode === "IMAGE") {
                runningMode = "VIDEO";
                await gestureRecognizer.setOptions({ runningMode: "VIDEO" });
            }

            let nowInMs = Date.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = gestureRecognizer.recognizeForVideo(video, nowInMs);

                overlayCtx.clearRect(0, 0, gestureOverlay.width, gestureOverlay.height);
                const drawingUtils = new DrawingUtils(overlayCtx);

                if (results && results.landmarks && results.landmarks.length > 0) {
                    const landmarks = results.landmarks[0];
                    drawingUtils.drawLandmarks(landmarks, { color: "#FF0000", lineWidth: 2 });

                    const indexFinger = landmarks[8]; // Index finger tip
                    const middleFinger = landmarks[12]; // Middle finger tip

                    // Map to paint canvas coordinates
                    const canvasX = (indexFinger.x * paintCanvas.width);
                    const canvasY = (indexFinger.y * paintCanvas.height);

                    // Update cursor position
                    const canvasRect = paintCanvas.getBoundingClientRect();
                    cursor.style.left = (canvasRect.left + canvasX - 5) + "px";
                    cursor.style.top = (canvasRect.top + canvasY - 5) + "px";

                    let gestureText = "";
                    if (results.gestures.length > 0) {
                        const gesture = results.gestures[0][0].categoryName;
                        const score = parseFloat(results.gestures[0][0].score * 100).toFixed(2);
                        gestureText = `Gesture: ${gesture} (${score}%)`;

                        // Check for click (index and middle fingers close together)
                        const fingerDistance = Math.sqrt(
                            Math.pow(indexFinger.x - middleFinger.x, 2) +
                            Math.pow(indexFinger.y - middleFinger.y, 2)
                        );

                        const isClicking = fingerDistance < 0.05; // Adjust threshold as needed

                        if (isClicking) {
                            if (!isDrawing) {
                                isDrawing = true;
                                lastX = canvasX;
                                lastY = canvasY;
                            }
                        } else if (isDrawing) {
                            isDrawing = false;
                        }

                        if (isDrawing) {
                            paintCtx.beginPath();
                            paintCtx.moveTo(lastX, lastY);
                            paintCtx.lineTo(canvasX, canvasY);
                            paintCtx.strokeStyle = isEraser ? "#FFFFFF" : colorPicker.value;
                            paintCtx.lineWidth = parseInt(brushSize.value);
                            paintCtx.lineCap = "round";
                            paintCtx.stroke();
                            lastX = canvasX;
                            lastY = canvasY;
                        }
                    } else {
                        gestureText = "No gesture detected";
                        isDrawing = false;
                    }

                    gestureOutput.textContent = gestureText + (isDrawing ? " - Drawing" : "");
                } else {
                    gestureOutput.textContent = "No hand detected";
                    cursor.style.display = "none";
                }
            }

            window.requestAnimationFrame(predictWebcam);
        }
    </script>
</body>
</html>
